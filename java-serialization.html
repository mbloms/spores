<!DOCTYPE html>
<html class="no-js" lang="eng" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serializing spores</title>
    <link rel="stylesheet" href="_theme/css/foundation.min.css">
    <link rel="stylesheet" href="_theme/css/app.css">
     <link rel="stylesheet" href="_theme/css/highlight.js/styles/github-gist.css"> 
  </head>
  <body>
    <div class="expanded row">
      <div class="small-12 medium-12 large-12 columns align-self-top">
        <div class="row">
          
          <header class="large-12 columns align-self-top a_header">
            <div class="row">
              <div class="large-12 columns a_limited top-bar">
                <div class="top-bar-left">
                  <p>Spores</p>

                </div>
                <div class="top-bar-right align-right row">
                  
                  
                    <form action="site-search.html" method="get" class="align-right a_search">
                      <input name="q" type="search"  placeholder="Search
" >
                      <button><img alt="&#1F50D;" src="_theme/images/images/search.svg" /></button>
                    </form>
                  
                </div>
              </div>
            </div>
          </header>
          
          <div class="small-12 medium-12 large-12 columns align-self-top a_limited a_main">
            <div class="row">
              
              <main class="columns large-order-2 sections" id="_sections">
                <h1 id="serializing-spores" class="a_section" data-magellan-target="serializing-spores">Serializing spores<a class="a_hlink" href="#serializing-spores"></a></h1>
<p>Spores can be serialized using two mechanisms: implicit-based pickling libraries
or <code class="hljs">{java.io, scala}.Serializable</code>-based libraries. In this tutorial, we will
explore the integration of spores with Java-based serialization alternatives,
and show how they can be used in Spark to provide a safer use of closures.</p>
<h2 id="goal" class="a_section" data-magellan-target="goal">Goal<a class="a_hlink" href="#goal"></a></h2>
<p>Help Spark users identify serialization issues at compile-time rather than
runtime. Concretely, this translates into addressing <a href="http://www.cakesolutions.net/teamblogs/demystifying-spark-serialisation-error">common</a> [1]
<a href="https://databricks.gitbooks.io/databricks-spark-knowledge-base/content/troubleshooting/javaionotserializableexception.html">serialization issues</a> [2].</p>
<h2 id="installation" class="a_section" data-magellan-target="installation">Installation<a class="a_hlink" href="#installation"></a></h2>
<p>Add the following sbt settings to your <code class="hljs">build.sbt</code>:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">resolvers += <span class="hljs-type">Resolver</span>.bintrayRepo(<span class="hljs-string">"scalacenter"</span>, <span class="hljs-string">"releases"</span>)
libraryDependencies += <span class="hljs-string">"ch.epfl.scala"</span> %% <span class="hljs-string">"spores"</span> % <span class="hljs-string">"0.4.0-M3"</span>
addCompilerPlugin(<span class="hljs-string">"ch.epfl.scala"</span> %% <span class="hljs-string">"spores-serialization"</span> % <span class="hljs-string">"0.4.0-M3"</span>)
</code></pre>
</div>
<blockquote class="note">
<p>These artifacts are only compatible with Scala 2.11.x.
A <a href="https://issues.scala-lang.org/browse/SI-10009">bug in 2.12.0</a> prevents us from releasing
a compatible version. <code class="hljs">spores</code> will be probably released for 2.12.1.</p>
</blockquote>
<h2 id="quickstart" class="a_section" data-magellan-target="quickstart">Quickstart<a class="a_hlink" href="#quickstart"></a></h2>
<p>Spores allow you to control the environment of a closure. To ensure that spores
are serializable-safe, all the captured variables are checked to be serializable.</p>
<p>This compiler plugin requires you to:</p>
<ol>
<li>Extend <code class="hljs">scala.Serializable</code> in the classes of all the captured types.</li>
<li>Close the class hierarchy of all the custom classes that you capture (<a href="java-serialization.html#closed-class-hierarchies">what is this?</a>).</li>
</ol>
<p>With these requirements, <code class="hljs">spores-serialization</code> makes its best to prove the
correct serializability of your spores.</p>
<h3 id="an-example" class="a_section" data-magellan-target="an-example">An example<a class="a_hlink" href="#an-example"></a></h3>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">import</span> scala.spores._
<span class="hljs-keyword">val</span> s = spore {
  <span class="hljs-keyword">val</span> capturedInt = <span class="hljs-number">8</span>
  <span class="hljs-keyword">val</span> capturedString = <span class="hljs-string">"Hello, World!"</span>
  <span class="hljs-keyword">val</span> capturedList = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
  (i: <span class="hljs-type">Int</span>) =&gt; {
    println(capturedString)
    capturedList.map(_ + i).contains(capturedInt)
  }
}
</code></pre>
</div>
<p>This code snippet compiles because primitives and <code class="hljs">{Scala, Java}</code> collections are serializable.
In it, we capture an <code class="hljs">Int</code>, a <code class="hljs">String</code> and a <code class="hljs">List[Int]</code> which can be successfully
sent over the wire.</p>
<p>But, why? The compiler plugin inspects the type of <code class="hljs">capturedInt</code>, <code class="hljs">capturedString</code> and
<code class="hljs">capturedList</code>. In this case, <code class="hljs">Int</code> is a primitive, <code class="hljs">String</code> extends <code class="hljs">java.io.Serializable</code>
and <code class="hljs">List[Int]</code> is a closed class hierarchy with a primitive (and serializable) type parameter
whose subclasses are safely serializable.</p>
<p>The compiler plugin performs a similar reasoning to the one explained before
to prove that certain types are serializable. Since Scala is very flexible and
allows user to abstract over their logic, <code class="hljs">spores-serialization</code> is able to perform
such analysis in more sophisticated situations.</p>
<p>Before introducing them, let's understand the underlying concepts and guarantees
that the transitive checks provide.</p>
<h2 id="basics" class="a_section" data-magellan-target="basics">Basics<a class="a_hlink" href="#basics"></a></h2>
<h3 id="closed-class-hierarchies" class="a_section" data-magellan-target="closed-class-hierarchies">Closed class hierarchies<a class="a_hlink" href="#closed-class-hierarchies"></a></h3>
<p>Closed class hierarchies play a key role in Scala because:</p>
<ul>
<li>allows the compiler to <a href="https://en.wikipedia.org/wiki/Closed-world_assumption">assume a closed-world</a> for a concrete set of classes;</li>
<li>macros and compiler plugins have <em>full</em> access to its definition and properties.</li>
</ul>
<p>This section sheds some light on the differences between the two and why
<code class="hljs">spores-serialization</code> requires closed class hierarchies to ensure the correct
serializability of your program.</p>
<h4 id="the-class-hierarchy" class="a_section" data-magellan-target="the-class-hierarchy">The class hierarchy<a class="a_hlink" href="#the-class-hierarchy"></a></h4>
<p>Traditionally, class hierarchies have always be open. Open class hierarchies
are handy and flexible for developers: they allow them to extend classes in any
file or project they want (if they are <em>visible</em>). However, such flexibility
hinders the static analysis of programs. For overcoming this limitation, we use
closed class hierarchies.</p>
<div class="row"><div class="small-expand columns a_xscroll a_table"><table>
<thead>
<tr><th>Open class hierarchy</th><th>Closed class hierarchy</th></tr>
</thead>
<tbody>
<tr><td><code class="language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span></td><td><code class="language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span></span></code></td></tr>
<tr><td><code class="language-scala"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">b: Int</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span></code></td><td><code class="language-scala"><span class="hljs-keyword">final </span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">b: Int</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span></code></td></tr>
<tr><td><code class="language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">b: Int</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span></code></td><td><code class="language-scala"><span class="hljs-keyword">final </span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">b: Int</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span></code></td></tr>
</tbody>
</table></div></div>
<p>A closed class hierarchy is a finite set of classes that share same hierarchy and are defined
in the same Scala file. They are defined as their counterpart except for the use of extra modifiers.
The rule of thumb is to define all the leafs as <code class="hljs">final</code>, and the root and intermediate traits
and classes as <code class="hljs">sealed</code>. Therefore, whenever you try to extend a sealed trait/class
or a <code class="hljs">final</code> class, the compiler will throw a happy error at you.</p>
<h4 id="motivation-of-sealed-class-hierarchies" class="a_section" data-magellan-target="motivation-of-sealed-class-hierarchies">Motivation of sealed class hierarchies<a class="a_hlink" href="#motivation-of-sealed-class-hierarchies"></a></h4>
<p>Transitive checking requires a full traversal of the class hierarchy. It needs to check
both class and trait definitions and <em>all their members</em> to prove that no serialization issues
can happen at runtime.</p>
<p>So, why cannot we just use open class hierarchies?</p>
<p>Because:</p>
<ol>
<li>Non-<code class="hljs">final</code> classes can be extended elsewhere. <code class="hljs">spores-serialization</code> could give false
positives if these externally defined classes are not serializable.</li>
<li>Intermediate super classes cannot be <code class="hljs">final</code>. Scala needs to guarantee that these classes
are only defined in the current compilation unit, otherwise false positives could happen.</li>
<li>The Scala compiler does not give us access to direct subclasses if the class hierarchy
is not sealed. This is a well-known <a href="https://issues.scala-lang.org/browse/SI-7046">limitation</a> of the Scala typer
and may have a <a href="https://github.com/scala/scala/pull/5284">partial fix soon</a>.</li>
</ol>
<h4 id="the-class-metamorphosis" class="a_section" data-magellan-target="the-class-metamorphosis">The class Metamorphosis<a class="a_hlink" href="#the-class-metamorphosis"></a></h4>
<p>So what should you do to make <code class="hljs">spores-serialization</code> transitively check all your program?
Ensure that all the captured variables in your spores are serializable and closed. If you
have scattered class definitions across different packages, bring them to the same file
and baptise the class hierarchy with <code class="hljs">sealed</code> and <code class="hljs">final</code> as described before.</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">import</span> scala.spores._
<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">b: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">b: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>

<span class="hljs-comment">// Force cast to Foo</span>
<span class="hljs-keyword">val</span> foo1: <span class="hljs-type">Foo</span> = <span class="hljs-type">Baz</span>(<span class="hljs-number">1</span>)
<span class="hljs-keyword">val</span> foo2: <span class="hljs-type">Foo</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Bar</span>(<span class="hljs-number">2</span>)
<span class="hljs-keyword">val</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-type">Bar</span>(<span class="hljs-number">2</span>)
spore {
  <span class="hljs-keyword">val</span> capturedFoo1 = foo1
  <span class="hljs-keyword">val</span> capturedFoo2 = foo2
  <span class="hljs-keyword">val</span> capturedBar = bar
  () =&gt; <span class="hljs-comment">// spore logic using `capturedFoo1`, `capturedFoo2` and `capturedBar`</span>
}
</code></pre>
</div>
<p>The previous example compiles. If you don't seal the hierarchy, <code class="hljs">spores-serialization</code> will
output the following error:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">[warn] /your/path/<span class="hljs-type">File</span>.scala:<span class="hljs-number">93</span>: <span class="hljs-type">Detected</span> open <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">hierarchy</span> <span class="hljs-title">in</span> `<span class="hljs-title">trait</span> <span class="hljs-title">Foo</span>`.</span>
[warn]   <span class="hljs-type">Transitive</span> inspection cannot ensure that <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">being</span> <span class="hljs-title">extended</span> <span class="hljs-title">somewhere</span> <span class="hljs-title">else</span>. <span class="hljs-title">For</span> <span class="hljs-title">a</span> <span class="hljs-title">complete</span> <span class="hljs-title">serializable</span> <span class="hljs-title">check</span>, <span class="hljs-title">class</span> <span class="hljs-title">hierarchies</span> <span class="hljs-title">need</span> <span class="hljs-title">to</span> <span class="hljs-title">be</span> <span class="hljs-title">closed</span>.</span>
[warn] 
[warn] <span class="hljs-type">Solution</span>: <span class="hljs-type">Close</span> the <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">hierarchy</span> <span class="hljs-title">by</span> <span class="hljs-title">marking</span> <span class="hljs-title">super</span> <span class="hljs-title">classes</span> <span class="hljs-title">as</span> `<span class="hljs-title">sealed</span>` <span class="hljs-title">and</span> <span class="hljs-title">sub</span> <span class="hljs-title">classes</span> <span class="hljs-title">as</span> `<span class="hljs-title">final</span>`.</span>
[warn]      
[warn]     <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> </span>{<span class="hljs-keyword">val</span> foo: <span class="hljs-type">String</span>}
[warn]           ^
</code></pre>
</div>
<p>Notice that capturing subclasses like <code class="hljs">Bar</code> or <code class="hljs">Baz</code> will never cause an error
because they are final and, by definition, have no subclass.</p>
<h4 id="a-escape-hatch" class="a_section" data-magellan-target="a-escape-hatch">A escape hatch<a class="a_hlink" href="#a-escape-hatch"></a></h4>
<p>The annotation <code class="hljs">@assumeClosed</code> is a escape hatch for users that <em>for some reason</em> cannot
turn their class hierarchy closed. It tells the compiler to assume that the class you're
capturing is closed, but unfortunately no analysis of the subclasses will be performed (SI-7046).
Therefore, its use is discouraged and only left for intrepid developers that like risk.</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">import</span> scala.spores._
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">b: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">b: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>

<span class="hljs-comment">// Force cast to Foo</span>
<span class="hljs-keyword">val</span> riskyFoo: <span class="hljs-type">Foo</span> = <span class="hljs-type">Baz</span>(<span class="hljs-number">1</span>)
<span class="hljs-keyword">val</span> s = spore {
  <span class="hljs-keyword">val</span> capturedFoo = (riskyFoo: <span class="hljs-type">Foo</span> <span class="hljs-meta">@assumeClosed</span>)
  () =&gt; <span class="hljs-comment">// spore logic</span>
}
</code></pre>
</div>
<h3 id="abstracting-over-the-logic" class="a_section" data-magellan-target="abstracting-over-the-logic">Abstracting over the logic<a class="a_hlink" href="#abstracting-over-the-logic"></a></h3>
<p>Sooner or later, your logic may become repetitive. <code class="hljs">spores-serialization</code> is capable
of allowing users to abstract over their logic and define spores at places where
the captured types are not fully defined.</p>
<p>For the following code snippet, assume that <code class="hljs">Foo</code> is a closed class hierarchy.</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">import</span> scala.spores._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span>[<span class="hljs-type">T</span> &lt;: <span class="hljs-type">Foo</span>](<span class="hljs-params">val wrapped: <span class="hljs-type">List</span>[<span class="hljs-type">T</span>]</span>) </span>{
  <span class="hljs-keyword">val</span> zippingSpore = spore {
    <span class="hljs-keyword">val</span> captured = wrapped
    (xs: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]) =&gt; xs.zip(captured)
  }
}
</code></pre>
</div>
<p>And if the wrapper is <code class="hljs">Serializable</code>, you can even send it accross the wire:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">import</span> scala.spores._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span>[<span class="hljs-type">T</span> &lt;: <span class="hljs-type">Foo</span>](<span class="hljs-params">val wrapped: <span class="hljs-type">List</span>[<span class="hljs-type">T</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> </span>{
  <span class="hljs-keyword">val</span> zippingSpore = spore {
    <span class="hljs-keyword">val</span> captured = wrapped
    (xs: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]) =&gt; xs.zip(captured)
  }
}

<span class="hljs-keyword">val</span> wrapper = <span class="hljs-keyword">new</span> <span class="hljs-type">Wrapper</span>(<span class="hljs-type">List</span>(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"Hello"</span>))
<span class="hljs-keyword">val</span> s = spore {
  <span class="hljs-keyword">val</span> serializedWrapper = wrapper
  () =&gt; serializedWrapper
}
</code></pre>
</div>
<p>Why are these working examples? Because <code class="hljs">Foo</code> is ensured to be a high bound of
the type parameter and <code class="hljs">Foo</code> is a closed class hierarchy.</p>
<p>While the previous examples work, users can also set the high bound to be
<code class="hljs">Serializable</code>:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">import</span> scala.spores._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span>[<span class="hljs-type">T</span> &lt;: <span class="hljs-type">Serializable</span>](<span class="hljs-params">val wrapped: <span class="hljs-type">List</span>[<span class="hljs-type">T</span>]</span>) </span>{
  <span class="hljs-keyword">val</span> zippingSpore = spore {
    <span class="hljs-keyword">val</span> captured = wrapped
    (xs: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]) =&gt; xs.zip(captured)
  }
}
</code></pre>
</div>
<p>But this results in the following warning:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code>TBD
</code></pre>
</div>
<p>Generally, proving that a type parameter extends <code class="hljs">scala.Serializable</code> is not enough
for ensuring the lack of type members because &quot;serializable&quot; classes may have fields
that are not. The previous code snippet is <strong>not the recommended way</strong> to use <code class="hljs">spores-serialization</code>.
It's better to allow the compiler plugin to do all the work if you don't necessarily
like debugging a runtime serialization error a Sunday night.</p>
<h3 id="transient-fields" class="a_section" data-magellan-target="transient-fields">Transient fields<a class="a_hlink" href="#transient-fields"></a></h3>
<p>In Java, variables may be marked <code class="hljs">transient</code> to indicate that they are not part of the persistent
state of an object and therefore will not be serialized (see <a href="https://en.wikibooks.org/wiki/Java_Programming/Keywords/transient">this</a> and the <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.3">Java Language Specification</a>).
In Scala, you can achieve the same goal by annotating the fields with <code class="hljs">@transient</code>.</p>
<p>By definition, transient fields are not part of the analyzed field, and
<code class="hljs">spores-serialization</code> will ignore its type even if it's not serializable.
Under the hood, when Java does initialize the unserialized class, a transient
field will hold no value so make sure that transient fields are not used in the
logic of your program.</p>
<h3 id="serializable-value-classes" class="a_section" data-magellan-target="serializable-value-classes">Serializable value classes<a class="a_hlink" href="#serializable-value-classes"></a></h3>
<p>By definition, value classes can <em>only</em> extend <code class="hljs">AnyVal</code>, which means they cannot be <code class="hljs">{java.io, scala}.Serializable</code>.
To overcome this limitation, the compiler plugin uses implicits to prove that a value class <code class="hljs">Foo</code> is serializable.
For proving it, you need to provide an implicit <code class="hljs">CanBeSerialized[Foo]</code> in the scope of
the spore definition.</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">import</span> scala.spores._

<span class="hljs-comment">// Value class definition somewhere</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">i: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyVal</span></span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Foo</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">FooIsSerializable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CanBeSerialized</span>[<span class="hljs-type">Foo</span>]</span>
}

<span class="hljs-comment">// Spore definition somewhere else</span>
<span class="hljs-keyword">import</span> <span class="hljs-type">Foo</span>._
<span class="hljs-keyword">val</span> foo = <span class="hljs-type">Foo</span>(<span class="hljs-number">5</span>)
<span class="hljs-keyword">val</span> s = spore {
  <span class="hljs-keyword">val</span> captured = foo
  () =&gt; <span class="hljs-comment">// spore logic using `captured`</span>
}
</code></pre>
</div>
<p>Thanks to the definition of <code class="hljs">FooIsSerializable</code> and the <code class="hljs">import Foo._</code> in the spore
definition, the compiler plugin is able to prove that the use of <code class="hljs">Foo</code> is safe.</p>
<blockquote class="note">
<p>Non-primitive value classes <em>may</em> be non-serializable. Its serialization fails when they require
allocation inside the spore body, because they need to be <a href="http://docs.scala-lang.org/overviews/core/value-classes.html">instantiated as a class <code class="hljs">Foo</code>
instead of avoiding the runtime object allocation</a>. This happens when:</p>
<ol>
<li>a value class is treated as another type.</li>
<li>a value class is assigned to an array.</li>
<li>doing runtime type tests, such as pattern matching.</li>
</ol>
<p>Therefore, you cannot use value classes if you use them in any situation that requires boxing.
This is a fundamental limitation of value classes that may be fixed in the future. For now,
the compiler plugin does not catch the misuse of value classes inside spores, so if you decide
to use them, be careful.</p>
</blockquote>
<h2 id="future-ideas" class="a_section" data-magellan-target="future-ideas">Future ideas<a class="a_hlink" href="#future-ideas"></a></h2>
<p>As a compiler plugin, <code class="hljs">spores-serialization</code> is capable of doing more than just
static type analysis. Here are some ideas for the future that may be considered
to be implemented depending on the community's response. Come to discuss them
at <a href="https://contributors.scala-lang.org/">Discourse</a> (<strong>TBD</strong>).</p>
<h3 id="warning-against-the-use-of-well-known-lazy-methods" class="a_section" data-magellan-target="warning-against-the-use-of-well-known-lazy-methods">Warning against the use of well-known 'lazy' methods<a class="a_hlink" href="#warning-against-the-use-of-well-known-lazy-methods"></a></h3>
<p>Methods whose implementation is lazy are generally not serializable because
they involve the creation of anonymous functions. Some examples are:</p>
<ol>
<li><a href="https://issues.scala-lang.org/browse/SI-5018"><code class="hljs">Map.withDefault</code></a></li>
<li><a href="https://issues.scala-lang.org/browse/SI-6654"><code class="hljs">Map.filterKeys</code></a></li>
<li><a href="https://issues.scala-lang.org/browse/SI-5048?jql=status%20=%20Open%20AND%20labels%20=%20serialization">Closures in initializer of structural types break serialization</a></li>
</ol>
<p>As these examples are not well-known in the Scala community and still persist,
<code class="hljs">spores-serialization</code> could warn when it detects them inside the spore bodies.</p>
<h3 id="kryo-support" class="a_section" data-magellan-target="kryo-support">Kryo support<a class="a_hlink" href="#kryo-support"></a></h3>
<p>There may be some missing pieces for working Kryo support. Spark users that
use Kryo instead of Java serialization could get a lot of benefits from using
<code class="hljs">spores</code> and <code class="hljs">spores-serialization</code>.</p>
<h3 id="dealing-with-other-serialization-issues" class="a_section" data-magellan-target="dealing-with-other-serialization-issues">Dealing with other serialization issues<a class="a_hlink" href="#dealing-with-other-serialization-issues"></a></h3>
<p>Serialization issues may happen when some classes are not in the classloaders,
like <a href="https://issues.scala-lang.org/browse/SI-9777?jql=status%20=%20Open%20AND%20labels%20=%20serialization">SI-9777</a>.
Is there <em>something</em> we can do to detect these errors before they happen?</p>

              </main>
              
              
                <div data-sticky-container class="small-12 medium-12 large-2 large-order-1 columns a_sitenav_container">
                  <nav class="a_sitenav" data-sticky data-sticky-on="large" data-anchor="_sections">
                    
                  <ul>
                     
  <li >
    
      <a href="spores.html">Spores</a>
    
    
  </li>
  
  <li >
    
      <a href="getting-started.html">Getting started</a>
    
    
  </li>
  
  <li  class="a_thispage" >
    
      <a href="java-serialization.html">Serializing spores</a>
    
    
  </li>
 
                  </ul>
                  </nav>
                </div>
              
              
              
                <div class="small-12 medium-12 large-2 large-order-3 columns a_show-for-xlarge" data-sticky-container>
                  <nav class="a_pagenav" data-sticky data-sticky-on="large" data-anchor="_sections">
                     <header><p>On This Page</p>
</header> 
                    <ul class="vertical menu" data-magellan>
                       
  <li>
    
       <a href="#serializing-spores">Serializing spores</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#goal">Goal</a> 
    
    
  </li>
  
  <li>
    
       <a href="#installation">Installation</a> 
    
    
  </li>
  
  <li>
    
       <a href="#quickstart">Quickstart</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#an-example">An example</a> 
    
    
  </li>
  </ul>
    
  </li>
  
  <li>
    
       <a href="#basics">Basics</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#closed-class-hierarchies">Closed class hierarchies</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#the-class-hierarchy">The class hierarchy</a> 
    
    
  </li>
  
  <li>
    
       <a href="#motivation-of-sealed-class-hierarchies">Motivation of sealed class hierarchies</a> 
    
    
  </li>
  
  <li>
    
       <a href="#the-class-metamorphosis">The class Metamorphosis</a> 
    
    
  </li>
  
  <li>
    
       <a href="#a-escape-hatch">A escape hatch</a> 
    
    
  </li>
  </ul>
    
  </li>
  
  <li>
    
       <a href="#abstracting-over-the-logic">Abstracting over the logic</a> 
    
    
  </li>
  
  <li>
    
       <a href="#transient-fields">Transient fields</a> 
    
    
  </li>
  
  <li>
    
       <a href="#serializable-value-classes">Serializable value classes</a> 
    
    
  </li>
  </ul>
    
  </li>
  
  <li>
    
       <a href="#future-ideas">Future ideas</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#warning-against-the-use-of-well-known-lazy-methods">Warning against the use of well-known &#x27;lazy&#x27; methods</a> 
    
    
  </li>
  
  <li>
    
       <a href="#kryo-support">Kryo support</a> 
    
    
  </li>
  
  <li>
    
       <a href="#dealing-with-other-serialization-issues">Dealing with other serialization issues</a> 
    
    
  </li>
  </ul>
    
  </li>
  </ul>
    
  </li>
 
                    </ul>
                  </nav>
                </div>
              
            </div>
          </div>
        </div>
      </div>
      
      <footer class="small-12 medium-12 large-12 columns align-self-bottom a_footer">
        <div class="row">
          <div class="small-12 medium-12 large-12 columns top-bar">
            <div class="top-bar-left">
              <p>Generated with <a href="https://github.com/szeiger/ornate">Ornate</a>.</p>

            </div>
            <div class="top-bar-right">
              <p>Â© Scala Center 2016</p>

            </div>
          </div>
        </div>
      </footer>
    </div>
    <script src="_theme/js/jquery.min.js"></script>
    <script src="_theme/js/what-input.min.js"></script>
    <script src="_theme/js/foundation.min.js"></script>
    
    <script src="_theme/js/app.js"></script>
    
  </body>
</html>
